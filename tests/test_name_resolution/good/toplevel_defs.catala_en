## Test basic toplevel values defs

```catala
declaration glob1 content decimal equals 44.12

declaration scope S:
  output a content decimal
  output b content A

declaration structure A:
   data y content boolean
   data z content decimal

declaration glob2 content A equals
    A { --y: glob1 >= 30. --z: 123. * 17. }

scope S:
   definition a equals glob1 * glob1
   definition b equals glob2
```

```catala-test-inline
$ catala Interpret -s S
[RESULT] Computation successful! Results:
[RESULT] a = 1946.5744
[RESULT] b = A { "y"= true; "z"= 2091. }
```

## Test toplevel function defs

```catala
declaration glob3 content decimal
    depends on x content money
    equals decimal of x + 10.

declaration scope S2:
  output a content decimal

scope S2:
   definition a equals glob3 of $44 + 100.
```

```catala-test-inline
$ catala Interpret -s S2
[RESULT] Computation successful! Results:
[RESULT] a = 154.
```

## Test function def with two args

```catala
declaration glob4 content decimal
    depends on x content money, y content decimal
    equals decimal of x * y + 10.

declaration scope S3:
  output a content decimal

scope S3:
   definition a equals 50. + glob4 of $44, 55.
```

```catala-test-inline
$ catala Interpret -s S3
[RESULT] Computation successful! Results:
[RESULT] a = 2480.
```

## Test inline defs in toplevel defs

(can't define inline functions yet)

```catala
declaration glob5 content decimal equals
    let x equals decimal of 2 * 3. in
    let y equals 1000. in
    x * y

declaration scope S4:
  output a content decimal

scope S4:
   definition a equals glob5 + 1.
```

```catala-test-inline
$ catala Interpret -s S4
[RESULT] Computation successful! Results:
[RESULT] a = 6001.
```


```catala-test-inline
$ catala scalc
let glob1_2 = 44.12

let glob3_3 (x_3: money) = return to_rat_mon x_3 +. 10.

let glob4_4 (x_4: money) (y_5: decimal) = return to_rat_mon x_4 *. y_5 +. 10.

let glob5_aux_5 =
  decl glob5_7 : any;
  let glob5_7 (x_8 : decimal) =
    decl y_9 : decimal;
    y_9 = 1000.;
    return x_8 *. y_9;
  return glob5_7 to_rat_int 2 *. 3.

let glob5_6 = glob5_aux_5 ()

let glob2_10 = A {"y": glob1_2 >=. 30., "z": 123. *. 17.}

let S2_6 (S2_in_11: S2_in {}) =
  decl temp_a_13 : any;
  try:
    decl temp_a_16 : any;
    let temp_a_16 (__17 : unit) =
      return glob3_3 $44.00 +. 100.;
    decl temp_a_14 : any;
    let temp_a_14 (__15 : unit) =
      return true;
    temp_a_13 = handle_default_1 [] temp_a_14 temp_a_16
  with EmptyError:
    temp_a_13 = dead_value_1;
    raise NoValueProvided;
  decl a_12 : decimal;
  a_12 = temp_a_13;
  return S2 {"a": a_12}

let S3_7 (S3_in_18: S3_in {}) =
  decl temp_a_20 : any;
  try:
    decl temp_a_23 : any;
    let temp_a_23 (__24 : unit) =
      return 50. +. glob4_4 $44.00 55.;
    decl temp_a_21 : any;
    let temp_a_21 (__22 : unit) =
      return true;
    temp_a_20 = handle_default_1 [] temp_a_21 temp_a_23
  with EmptyError:
    temp_a_20 = dead_value_1;
    raise NoValueProvided;
  decl a_19 : decimal;
  a_19 = temp_a_20;
  return S3 {"a": a_19}

let S4_8 (S4_in_25: S4_in {}) =
  decl temp_a_27 : any;
  try:
    decl temp_a_30 : any;
    let temp_a_30 (__31 : unit) =
      return glob5_6 +. 1.;
    decl temp_a_28 : any;
    let temp_a_28 (__29 : unit) =
      return true;
    temp_a_27 = handle_default_1 [] temp_a_28 temp_a_30
  with EmptyError:
    temp_a_27 = dead_value_1;
    raise NoValueProvided;
  decl a_26 : decimal;
  a_26 = temp_a_27;
  return S4 {"a": a_26}

let S_9 (S_in_32: S_in {}) =
  decl temp_a_40 : any;
  try:
    decl temp_a_43 : any;
    let temp_a_43 (__44 : unit) =
      return glob1_2 *. glob1_2;
    decl temp_a_41 : any;
    let temp_a_41 (__42 : unit) =
      return true;
    temp_a_40 = handle_default_1 [] temp_a_41 temp_a_43
  with EmptyError:
    temp_a_40 = dead_value_1;
    raise NoValueProvided;
  decl a_33 : decimal;
  a_33 = temp_a_40;
  decl temp_b_35 : any;
  try:
    decl temp_b_38 : any;
    let temp_b_38 (__39 : unit) =
      return glob2_10;
    decl temp_b_36 : any;
    let temp_b_36 (__37 : unit) =
      return true;
    temp_b_35 = handle_default_1 [] temp_b_36 temp_b_38
  with EmptyError:
    temp_b_35 = dead_value_1;
    raise NoValueProvided;
  decl b_34 : A {"y": bool; "z": decimal};
  b_34 = temp_b_35;
  return S {"a": a_33, "b": b_34}
```
