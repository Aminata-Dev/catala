```catala
declaration structure Result:
  data r content integer depends on z content integer

declaration scope SubFoo:
  input x content integer
  output y content integer depends on z content integer

declaration scope Foo:
  internal r content Result
  output z content integer

scope SubFoo:
  definition y of z equals x + z

scope Foo:
  definition r equals Result { --r: (output of SubFoo with { -- x: 10 }).y }
  definition z equals r.r of 1
```

Closure conversion fails because the type of `Result` should change to reflect
the transformed closure but we don't allow our closure conversion to change
user-defined types.

```catala-test-inline
$ catala Lcalc --avoid_exceptions -O --closure_conversion
type eoption =  | ENone of unit  | ESome of any

type Result = { r: eoption (((), integer) → eoption integer * ()); }

type SubFoo = {
  y: eoption
       (((eoption integer), integer) → eoption integer * (eoption integer));
  }

type Foo = { z: eoption integer; }

type SubFoo_in = { x_in: eoption integer; }

type Foo_in = { }
 
let scope SubFoo
  (SubFoo_in: SubFoo_in {x_in: eoption integer})
  : SubFoo {
      y:
        eoption
          (((eoption integer), integer) → eoption integer *
            (eoption integer))
    }
  =
  let get x : eoption integer = SubFoo_in.x_in in
  let set y :
      eoption
        (((eoption integer), integer) → eoption integer * (eoption integer))
      =
    ESome
      (λ (env: (eoption integer)) (z: integer) →
        ESome
          match
            (match env.0 with
             | ENone _ → ENone _
             | ESome x_0 → ESome (x_0 + z))
            with
          | ENone _ → raise NoValueProvided
          | ESome y → y, (x))
  in
  return { SubFoo y = y; }
let scope Foo (Foo_in: Foo_in): Foo {z: eoption integer} =
  let set r :
      eoption Result {r: eoption (((), integer) → eoption integer * ())} =
    ESome
      { Result
        r =
          ESome
            (λ (env: any) (param0: integer) →
              match (SubFoo { SubFoo_in x_in = ESome 10; }).y with
              | ENone _ → ENone _
              | ESome r → r.0 r.1 param0, ());
      }
  in
  let set z : eoption integer =
    ESome
      match
        (match (match r with
                | ENone _ → ENone _
                | ESome r → r.r) with
         | ENone _ → ENone _
         | ESome r → r.0 r.1 1)
        with
      | ENone _ → raise NoValueProvided
      | ESome z → z
  in
  return { Foo z = z; }

```
