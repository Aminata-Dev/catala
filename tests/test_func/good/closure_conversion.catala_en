## Article

```catala
declaration scope S:
  internal f content integer depends on y content integer
  input x content boolean
  output z content integer

scope S:
  definition f of y equals if x then y else - y
  definition z equals f of -1
```

```catala-test-inline
$ catala Lcalc -s S --avoid_exceptions -O --closure_conversion
let scope S (S_in: S_in {x_in: option bool}): S {z: option integer} =
  let get x : any = S_in.x_in in
  let set f : any =
    ESome
      let f : any =
        λ (env: any) (y: integer) →
        let x : any = env.0 in
        ESome
          match
            (match x with
             | ENone _ → ENone _
             | ESome x1 → if x1 then ESome y else ESome - y)
            with
          | ENone _ → raise NoValueProvided
          | ESome f → f
      in
      (f, (x))
  in
  let set z : any =
    ESome
      match
        (match f with
         | ENone _ → ENone _
         | ESome f →
           let code_and_env : any = f in
           let code : any = code_and_env.0 in
           let env : any = code_and_env.1 in
           code env -1)
        with
      | ENone _ → raise NoValueProvided
      | ESome z → z
  in
  return { S z = z; }
let scope S (S_in: S_in {x_in: option bool}): S {z: option integer} =
  let get x : option bool = S_in.x_in in
  let set f :
      option (((option bool), integer) → option integer * (option bool)) =
    ESome
      (λ (env: (option bool)) (y: integer) →
        ESome
          match
            (match env.0 with
             | ENone _ → ENone _
             | ESome x → if x then ESome y else ESome - y)
            with
          | ENone _ → raise NoValueProvided
          | ESome f → f, (x))
  in
  let set z : option integer =
    ESome
      match (match f with
             | ENone _ → ENone _
             | ESome f → f.0 f.1 -1) with
      | ENone _ → raise NoValueProvided
      | ESome z → z
  in
  return { S z = z; }
```
