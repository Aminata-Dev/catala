## Test

```catala
declaration scope A:
  context f content integer depends on x content integer

declaration scope B:
  input b content boolean
  a scope A

scope A:
  definition f of x equals x + 1

scope B:
  definition a.f of x under condition b and x > 0 consequence equals x - 1
```

```catala-test-inline
$ catala Scopelang -s B
[WARNING] In scope "A", the variable "f" is never used anywhere; maybe it's unnecessary?

┌─⯈ tests/test_func/good/context_func.catala_en:5.10-11:
└─┐
5 │   context f content integer depends on x content integer
  │           ‾
  └─ Test
let scope B (b: bool|input) =
  let a.f : integer → integer =
    λ (x: integer) →
      ⟨true ⊢ ⟨ ⟨b && x >! 0 ⊢ x -! 1⟩ | false ⊢ ∅ ⟩⟩;
  call A[a]
```

```catala-test-inline
$ catala Dcalc -s A
[WARNING] In scope "A", the variable "f" is never used anywhere; maybe it's unnecessary?

┌─⯈ tests/test_func/good/context_func.catala_en:5.10-11:
└─┐
5 │   context f content integer depends on x content integer
  │           ‾
  └─ Test
let scope A (A_in: A_in): A =
  let get f : integer → integer = A_in."f_in" in
  let set f : integer → integer =
    λ (x: integer) →
      error_empty
        ⟨ f x
        | true
          ⊢ ⟨true ⊢ ⟨ ⟨true ⊢ x +! 1⟩ | false ⊢ ∅ ⟩⟩ ⟩
    in
  return {}_A
```

```catala-test-inline
$ catala Dcalc -s B
[WARNING] In scope "A", the variable "f" is never used anywhere; maybe it's unnecessary?

┌─⯈ tests/test_func/good/context_func.catala_en:5.10-11:
└─┐
5 │   context f content integer depends on x content integer
  │           ‾
  └─ Test
let scope B (B_in: B_in): B =
  let get b : bool = B_in."b_in" in
  let sub_set a.f : integer → integer =
    λ (x: integer) →
      ⟨true ⊢ ⟨ ⟨b && x >! 0 ⊢ x -! 1⟩ | false ⊢ ∅ ⟩⟩ in
  let call result : A = A { "f_in" = a.f}_A_in in
  return {}_B
```
