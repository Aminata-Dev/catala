```catala
declaration structure Result:
  data r content integer depends on z content integer
  data q content integer

declaration scope SubFoo1:
  input output x content integer
  output y content integer depends on z content integer

declaration scope SubFoo2:
  input output x1 content integer
  input x2 content integer
  output y content integer depends on z content integer


declaration scope Foo:
  context b content boolean
  internal r content Result
  output z content integer

scope SubFoo1:
  definition y of z equals x + z

scope SubFoo2:
  definition y of z equals x1 + x2 + z


scope Foo:
  definition b equals true
  definition r equals
    if b then
      let f equals output of SubFoo1 with { -- x: 10 } in
      Result { --r: f.y --q: f.x }
    else
      let f equals output of SubFoo2 with { -- x1: 10 -- x2: 10 } in
      Result { --r: f.y --q: f.x1 }
  definition z equals r.r of 1
```

This test case is tricky because it creates a situation where the type of the
two closures in Foo.r are different even with optimizations enabled.
TODO fix this.

```catala-test-inline
$ catala Lcalc --avoid_exceptions -O --closure_conversion -s Foo
let scope Foo
  (Foo_in: Foo_in {b_in: eoption bool})
  : Foo {z: eoption integer}
  =
  let get b : eoption bool = Foo_in.b_in in
  let set b : eoption bool =
    ESome
      match
        (handle_default_opt
           [ b ]
           (λ (_: unit) → ESome true)
           (λ (_: unit) → ESome true))
        with
      | ENone _ → raise NoValueProvided
      | ESome b → b
  in
  let set r :
      eoption
        Result {
          r:
            eoption
              ((closure_env, integer) → eoption integer * closure_env);
          q: eoption integer
        } =
    ESome
      match
        (match b with
         | ENone _ → ENone _
         | ESome b →
           if b
           then
             match
               (match (SubFoo1 { SubFoo1_in x_in = ESome 10; }).x with
                | ENone _ → ENone _
                | ESome result_0 →
                  ESome
                    { SubFoo1
                      x = ESome result_0;
                      y =
                        ESome
                          (λ (env: closure_env) (param0: integer) →
                            match
                              (SubFoo1 { SubFoo1_in x_in = ESome 10; }).y
                              with
                            | ENone _ → ENone _
                            | ESome result →
                              let code_and_env :
                                  ((closure_env, integer) → eoption integer *
                                    closure_env) =
                                result
                              in
                              code_and_env.0 code_and_env.1 param0,
                            to_closure_env ());
                    })
               with
             | ENone _ → ENone _
             | ESome f →
               match f.x with
               | ENone _ → ENone _
               | ESome f_1 →
                 match f.y with
                 | ENone _ → ENone _
                 | ESome f_0 → ESome { Result r = ESome f_0; q = ESome f_1; }
           else
             match
               (match
                  (SubFoo2 { SubFoo2_in x1_in = ESome 10; x2_in = ESome 10; }).
                    x1
                  with
                | ENone _ → ENone _
                | ESome result_0 →
                  ESome
                    { SubFoo2
                      x1 = ESome result_0;
                      y =
                        ESome
                          (λ (env: closure_env) (param0: integer) →
                            match
                              (SubFoo2
                                 { SubFoo2_in
                                   x1_in = ESome 10;
                                   x2_in = ESome 10;
                                 }).
                                y
                              with
                            | ENone _ → ENone _
                            | ESome result →
                              let code_and_env :
                                  ((closure_env, integer) → eoption integer *
                                    closure_env) =
                                result
                              in
                              code_and_env.0 code_and_env.1 param0,
                            to_closure_env ());
                    })
               with
             | ENone _ → ENone _
             | ESome f →
               match f.x1 with
               | ENone _ → ENone _
               | ESome f_1 →
                 match f.y with
                 | ENone _ → ENone _
                 | ESome f_0 → ESome { Result r = ESome f_0; q = ESome f_1; })
        with
      | ENone _ → raise NoValueProvided
      | ESome r → r
  in
  let set z : eoption integer =
    ESome
      match
        (match (match r with
                | ENone _ → ENone _
                | ESome r → r.r) with
         | ENone _ → ENone _
         | ESome r →
           let code_and_env :
               ((closure_env, integer) → eoption integer * closure_env) =
             r
           in
           code_and_env.0 code_and_env.1 1)
        with
      | ENone _ → raise NoValueProvided
      | ESome z → z
  in
  return { Foo z = z; }
```

```catala-test-inline
$ catala Interpret_lcalc -s Foo --avoid_exceptions -O --closure_conversion
[RESULT] Computation successful! Results:
[RESULT] z = ESome 11
```
