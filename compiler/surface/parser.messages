source_file: BEGIN_CODE DECLARATION ENUM UIDENT COLON ALT UIDENT CONTENT TEXT YEAR
##
## Ends in an error in state: 333.
##
## list(enum_decl_line) -> enum_decl_line . list(enum_decl_line) [ SCOPE END_CODE DECLARATION ]
##
## The known suffix of the stack is as follows:
## enum_decl_line
##

expected another enum case, or a new declaration or scope use

source_file: BEGIN_CODE DECLARATION ENUM UIDENT COLON ALT UIDENT CONTENT YEAR
##
## Ends in an error in state: 329.
##
## option(enum_decl_line_payload) -> CONTENT . typ [ SCOPE END_CODE DECLARATION ALT ]
##
## The known suffix of the stack is as follows:
## CONTENT
##

expected a content type

source_file: BEGIN_CODE DECLARATION ENUM UIDENT COLON ALT UIDENT YEAR
##
## Ends in an error in state: 328.
##
## enum_decl_line -> ALT constructor . option(enum_decl_line_payload) [ SCOPE END_CODE DECLARATION ALT ]
##
## The known suffix of the stack is as follows:
## ALT constructor
##

expected a payload for your enum case, or another case or declaration

source_file: BEGIN_CODE DECLARATION ENUM UIDENT COLON ALT YEAR
##
## Ends in an error in state: 327.
##
## enum_decl_line -> ALT . constructor option(enum_decl_line_payload) [ SCOPE END_CODE DECLARATION ALT ]
##
## The known suffix of the stack is as follows:
## ALT
##

expected the name of an enum case

source_file: BEGIN_CODE DECLARATION ENUM UIDENT COLON YEAR
##
## Ends in an error in state: 326.
##
## code_item -> DECLARATION ENUM constructor COLON . list(enum_decl_line) [ SCOPE END_CODE DECLARATION ]
##
## The known suffix of the stack is as follows:
## DECLARATION ENUM constructor COLON
##

expected an enum case

source_file: BEGIN_CODE DECLARATION ENUM UIDENT YEAR
##
## Ends in an error in state: 325.
##
## code_item -> DECLARATION ENUM constructor . COLON list(enum_decl_line) [ SCOPE END_CODE DECLARATION ]
##
## The known suffix of the stack is as follows:
## DECLARATION ENUM constructor
##

expected a colon

source_file: BEGIN_CODE DECLARATION ENUM YEAR
##
## Ends in an error in state: 324.
##
## code_item -> DECLARATION ENUM . constructor COLON list(enum_decl_line) [ SCOPE END_CODE DECLARATION ]
##
## The known suffix of the stack is as follows:
## DECLARATION ENUM
##

expected the name of your enum








source_file: BEGIN_CODE DECLARATION SCOPE UIDENT COLON YEAR
##
## Ends in an error in state: 299.
##
## code_item -> DECLARATION SCOPE constructor COLON . nonempty_list(scope_decl_item) [ SCOPE END_CODE DECLARATION ]
##
## The known suffix of the stack is as follows:
## DECLARATION SCOPE constructor COLON
##

expected a context item introduced by "context"

source_file: BEGIN_CODE DECLARATION SCOPE UIDENT YEAR
##
## Ends in an error in state: 298.
##
## code_item -> DECLARATION SCOPE constructor . COLON nonempty_list(scope_decl_item) [ SCOPE END_CODE DECLARATION ]
##
## The known suffix of the stack is as follows:
## DECLARATION SCOPE constructor
##

expected a colon followed by the list of context items of this scope

source_file: BEGIN_CODE DECLARATION SCOPE YEAR
##
## Ends in an error in state: 297.
##
## code_item -> DECLARATION SCOPE . constructor COLON nonempty_list(scope_decl_item) [ SCOPE END_CODE DECLARATION ]
##
## The known suffix of the stack is as follows:
## DECLARATION SCOPE
##

expected the name of the scope you are declaring

source_file: BEGIN_CODE DECLARATION STRUCT UIDENT COLON CONDITION LIDENT DEPENDS COLLECTION YEAR
##
## Ends in an error in state: 283.
##
## typ -> COLLECTION . typ [ STATE SCOPE OUTPUT INTERNAL INPUT LIDENT END_CODE DEPENDS DECLARATION DATA CONTEXT CONDITION ALT ]
##
## The known suffix of the stack is as follows:
## COLLECTION
##

expected a new struct data, or another declaration or scope use

source_file: BEGIN_CODE DECLARATION STRUCT UIDENT COLON CONDITION LIDENT DEPENDS TEXT YEAR
##
## Ends in an error in state: 292.
##
## list(struct_scope) -> struct_scope . list(struct_scope) [ SCOPE END_CODE DECLARATION ]
##
## The known suffix of the stack is as follows:
## struct_scope
##

expected a new struct data, or another declaration or scope use

source_file: BEGIN_CODE DECLARATION STRUCT UIDENT COLON CONDITION LIDENT DEPENDS YEAR
##
## Ends in an error in state: 289.
##
## option(struct_scope_func) -> DEPENDS . typ [ STATE SCOPE OUTPUT INTERNAL INPUT LIDENT END_CODE DECLARATION DATA CONTEXT CONDITION ]
##
## The known suffix of the stack is as follows:
## DEPENDS
##

expected the type of the parameter of this struct data function

source_file: BEGIN_CODE DECLARATION STRUCT UIDENT COLON CONDITION LIDENT YEAR
##
## Ends in an error in state: 288.
##
## struct_scope -> struct_scope_base . option(struct_scope_func) [ SCOPE END_CODE DECLARATION DATA CONDITION ]
##
## The known suffix of the stack is as follows:
## struct_scope_base
##

expected a new struct data, or another declaration or scope use

source_file: BEGIN_CODE DECLARATION STRUCT UIDENT COLON CONDITION YEAR
##
## Ends in an error in state: 294.
##
## struct_scope_base -> condition_pos . ident [ SCOPE END_CODE DEPENDS DECLARATION DATA CONDITION ]
##
## The known suffix of the stack is as follows:
## condition_pos
##

expected the name of this struct condition

source_file: BEGIN_CODE DECLARATION STRUCT UIDENT COLON DATA LIDENT CONTENT YEAR
##
## Ends in an error in state: 282.
##
## struct_scope_base -> DATA ident CONTENT . typ [ SCOPE END_CODE DEPENDS DECLARATION DATA CONDITION ]
##
## The known suffix of the stack is as follows:
## DATA ident CONTENT
##

expected the type of this struct data

source_file: BEGIN_CODE DECLARATION STRUCT UIDENT COLON DATA LIDENT YEAR
##
## Ends in an error in state: 281.
##
## struct_scope_base -> DATA ident . CONTENT typ [ SCOPE END_CODE DEPENDS DECLARATION DATA CONDITION ]
##
## The known suffix of the stack is as follows:
## DATA ident
##

expected the type of this struct data, introduced by the content keyword

source_file: BEGIN_CODE DECLARATION STRUCT UIDENT COLON DATA YEAR
##
## Ends in an error in state: 280.
##
## struct_scope_base -> DATA . ident CONTENT typ [ SCOPE END_CODE DEPENDS DECLARATION DATA CONDITION ]
##
## The known suffix of the stack is as follows:
## DATA
##

expected the name of this struct data

source_file: BEGIN_CODE DECLARATION STRUCT UIDENT COLON YEAR
##
## Ends in an error in state: 279.
##
## code_item -> DECLARATION STRUCT constructor COLON . list(struct_scope) [ SCOPE END_CODE DECLARATION ]
##
## The known suffix of the stack is as follows:
## DECLARATION STRUCT constructor COLON
##

expected struct data or condition

source_file: BEGIN_CODE DECLARATION STRUCT UIDENT YEAR
##
## Ends in an error in state: 278.
##
## code_item -> DECLARATION STRUCT constructor . COLON list(struct_scope) [ SCOPE END_CODE DECLARATION ]
##
## The known suffix of the stack is as follows:
## DECLARATION STRUCT constructor
##

expected a colon

source_file: BEGIN_CODE DECLARATION STRUCT YEAR
##
## Ends in an error in state: 277.
##
## code_item -> DECLARATION STRUCT . constructor COLON list(struct_scope) [ SCOPE END_CODE DECLARATION ]
##
## The known suffix of the stack is as follows:
## DECLARATION STRUCT
##

expected the struct name

source_file: BEGIN_CODE DECLARATION YEAR
##
## Ends in an error in state: 276.
##
## code_item -> DECLARATION . STRUCT constructor COLON list(struct_scope) [ SCOPE END_CODE DECLARATION ]
## code_item -> DECLARATION . SCOPE constructor COLON nonempty_list(scope_decl_item) [ SCOPE END_CODE DECLARATION ]
## code_item -> DECLARATION . ENUM constructor COLON list(enum_decl_line) [ SCOPE END_CODE DECLARATION ]
##
## The known suffix of the stack is as follows:
## DECLARATION
##

expected the kind of the declaration (struct, scope or enum)

source_file: BEGIN_CODE SCOPE UIDENT COLON ASSERTION CARDINAL THEN
##
## Ends in an error in state: 237.
##
## assertion_base -> naked_expression . [ SCOPE RULE LABEL EXCEPTION END_CODE DEFINITION DECLARATION ASSERTION ]
## naked_expression -> naked_expression . DOT ident [ XOR WITH SCOPE RULE PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER LABEL GREATER_EQUAL GREATER FOR EXCEPTION EQUAL END_CODE DOT DIV DEFINITION DECLARATION CONTAINS ASSERTION AND ]
## naked_expression -> naked_expression . DOT constructor DOT ident [ XOR WITH SCOPE RULE PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER LABEL GREATER_EQUAL GREATER FOR EXCEPTION EQUAL END_CODE DOT DIV DEFINITION DECLARATION CONTAINS ASSERTION AND ]
## naked_expression -> naked_expression . OF naked_expression [ XOR WITH SCOPE RULE PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER LABEL GREATER_EQUAL GREATER FOR EXCEPTION EQUAL END_CODE DOT DIV DEFINITION DECLARATION CONTAINS ASSERTION AND ]
## naked_expression -> naked_expression . WITH constructor_binding [ XOR WITH SCOPE RULE PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER LABEL GREATER_EQUAL GREATER FOR EXCEPTION EQUAL END_CODE DOT DIV DEFINITION DECLARATION CONTAINS ASSERTION AND ]
## naked_expression -> naked_expression . CONTAINS naked_expression [ XOR WITH SCOPE RULE PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER LABEL GREATER_EQUAL GREATER FOR EXCEPTION EQUAL END_CODE DOT DIV DEFINITION DECLARATION CONTAINS ASSERTION AND ]
## naked_expression -> naked_expression . FOR ident AMONG naked_expression [ XOR WITH SCOPE RULE PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER LABEL GREATER_EQUAL GREATER FOR EXCEPTION EQUAL END_CODE DOT DIV DEFINITION DECLARATION CONTAINS ASSERTION AND ]
## naked_expression -> naked_expression . MULT naked_expression [ XOR WITH SCOPE RULE PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER LABEL GREATER_EQUAL GREATER FOR EXCEPTION EQUAL END_CODE DOT DIV DEFINITION DECLARATION CONTAINS ASSERTION AND ]
## naked_expression -> naked_expression . DIV naked_expression [ XOR WITH SCOPE RULE PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER LABEL GREATER_EQUAL GREATER FOR EXCEPTION EQUAL END_CODE DOT DIV DEFINITION DECLARATION CONTAINS ASSERTION AND ]
## naked_expression -> naked_expression . PLUS naked_expression [ XOR WITH SCOPE RULE PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER LABEL GREATER_EQUAL GREATER FOR EXCEPTION EQUAL END_CODE DOT DIV DEFINITION DECLARATION CONTAINS ASSERTION AND ]
## naked_expression -> naked_expression . MINUS naked_expression [ XOR WITH SCOPE RULE PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER LABEL GREATER_EQUAL GREATER FOR EXCEPTION EQUAL END_CODE DOT DIV DEFINITION DECLARATION CONTAINS ASSERTION AND ]
## naked_expression -> naked_expression . PLUSPLUS naked_expression [ XOR WITH SCOPE RULE PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER LABEL GREATER_EQUAL GREATER FOR EXCEPTION EQUAL END_CODE DOT DIV DEFINITION DECLARATION CONTAINS ASSERTION AND ]
## naked_expression -> naked_expression . compare_op naked_expression [ XOR WITH SCOPE RULE PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER LABEL GREATER_EQUAL GREATER FOR EXCEPTION EQUAL END_CODE DOT DIV DEFINITION DECLARATION CONTAINS ASSERTION AND ]
## naked_expression -> naked_expression . OR naked_expression [ XOR WITH SCOPE RULE PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER LABEL GREATER_EQUAL GREATER FOR EXCEPTION EQUAL END_CODE DOT DIV DEFINITION DECLARATION CONTAINS ASSERTION AND ]
## naked_expression -> naked_expression . XOR naked_expression [ XOR WITH SCOPE RULE PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER LABEL GREATER_EQUAL GREATER FOR EXCEPTION EQUAL END_CODE DOT DIV DEFINITION DECLARATION CONTAINS ASSERTION AND ]
## naked_expression -> naked_expression . AND naked_expression [ XOR WITH SCOPE RULE PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER LABEL GREATER_EQUAL GREATER FOR EXCEPTION EQUAL END_CODE DOT DIV DEFINITION DECLARATION CONTAINS ASSERTION AND ]
##
## The known suffix of the stack is as follows:
## naked_expression
##

expected a new scope use item

source_file: BEGIN_CODE SCOPE UIDENT COLON ASSERTION FIXED LIDENT BY YEAR
##
## Ends in an error in state: 234.
##
## assertion -> FIXED separated_nonempty_list(DOT,ident) BY . ident [ SCOPE RULE LABEL EXCEPTION END_CODE DEFINITION DECLARATION ASSERTION ]
##
## The known suffix of the stack is as follows:
## FIXED separated_nonempty_list(DOT,ident) BY
##

expected the legislative text by which the value of the variable is fixed

source_file: BEGIN_CODE SCOPE UIDENT COLON ASSERTION FIXED LIDENT WITH_V
##
## Ends in an error in state: 233.
##
## assertion -> FIXED separated_nonempty_list(DOT,ident) . BY ident [ SCOPE RULE LABEL EXCEPTION END_CODE DEFINITION DECLARATION ASSERTION ]
##
## The known suffix of the stack is as follows:
## FIXED separated_nonempty_list(DOT,ident)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production separated_nonempty_list(DOT,ident) -> ident
##

expected the legislative text by which the value of the variable is fixed

source_file: BEGIN_CODE SCOPE UIDENT COLON ASSERTION FIXED YEAR
##
## Ends in an error in state: 232.
##
## assertion -> FIXED . separated_nonempty_list(DOT,ident) BY ident [ SCOPE RULE LABEL EXCEPTION END_CODE DEFINITION DECLARATION ASSERTION ]
##
## The known suffix of the stack is as follows:
## FIXED
##

expected the name of the variable that should be fixed


source_file: BEGIN_CODE SCOPE UIDENT COLON ASSERTION UNDER_CONDITION TRUE THEN
##
## Ends in an error in state: 230.
##
## condition_consequence -> UNDER_CONDITION naked_expression . CONSEQUENCE [ BAR TRUE SUM STATE OUTPUT NOT MONEY_AMOUNT MONEY MINUS MINIMUM MAXIMUM MATCH LBRACKET LPAREN LET INT_LITERAL IF LIDENT FOR FILLED FALSE EXISTS DEFINED_AS DECIMAL_LITERAL DECIMAL UIDENT CARDINAL ]
## naked_expression -> naked_expression . DOT ident [ XOR WITH PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS CONSEQUENCE AND ]
## naked_expression -> naked_expression . DOT constructor DOT ident [ XOR WITH PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS CONSEQUENCE AND ]
## naked_expression -> naked_expression . OF naked_expression [ XOR WITH PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS CONSEQUENCE AND ]
## naked_expression -> naked_expression . WITH constructor_binding [ XOR WITH PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS CONSEQUENCE AND ]
## naked_expression -> naked_expression . CONTAINS naked_expression [ XOR WITH PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS CONSEQUENCE AND ]
## naked_expression -> naked_expression . FOR ident AMONG naked_expression [ XOR WITH PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS CONSEQUENCE AND ]
## naked_expression -> naked_expression . MULT naked_expression [ XOR WITH PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS CONSEQUENCE AND ]
## naked_expression -> naked_expression . DIV naked_expression [ XOR WITH PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS CONSEQUENCE AND ]
## naked_expression -> naked_expression . PLUS naked_expression [ XOR WITH PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS CONSEQUENCE AND ]
## naked_expression -> naked_expression . MINUS naked_expression [ XOR WITH PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS CONSEQUENCE AND ]
## naked_expression -> naked_expression . PLUSPLUS naked_expression [ XOR WITH PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS CONSEQUENCE AND ]
## naked_expression -> naked_expression . compare_op naked_expression [ XOR WITH PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS CONSEQUENCE AND ]
## naked_expression -> naked_expression . OR naked_expression [ XOR WITH PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS CONSEQUENCE AND ]
## naked_expression -> naked_expression . XOR naked_expression [ XOR WITH PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS CONSEQUENCE AND ]
## naked_expression -> naked_expression . AND naked_expression [ XOR WITH PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS CONSEQUENCE AND ]
##
## The known suffix of the stack is as follows:
## UNDER_CONDITION naked_expression
##

expected a consequence for this definition under condition

source_file: BEGIN_CODE SCOPE UIDENT COLON ASSERTION UNDER_CONDITION YEAR
##
## Ends in an error in state: 229.
##
## condition_consequence -> UNDER_CONDITION . naked_expression CONSEQUENCE [ BAR TRUE SUM STATE OUTPUT NOT MONEY_AMOUNT MONEY MINUS MINIMUM MAXIMUM MATCH LBRACKET LPAREN LET INT_LITERAL IF LIDENT FOR FILLED FALSE EXISTS DEFINED_AS DECIMAL_LITERAL DECIMAL UIDENT CARDINAL ]
##
## The known suffix of the stack is as follows:
## UNDER_CONDITION
##

expected an expression for this condition

source_file: BEGIN_CODE SCOPE UIDENT COLON ASSERTION VARIES LIDENT UNDER_CONDITION
##
## Ends in an error in state: 219.
##
## assertion -> VARIES separated_nonempty_list(DOT,ident) . WITH_V naked_expression option(variation_type) [ SCOPE RULE LABEL EXCEPTION END_CODE DEFINITION DECLARATION ASSERTION ]
##
## The known suffix of the stack is as follows:
## VARIES separated_nonempty_list(DOT,ident)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production separated_nonempty_list(DOT,ident) -> ident
##

expected an indication about what this variable varies with

source_file: BEGIN_CODE SCOPE UIDENT COLON ASSERTION VARIES LIDENT WITH_V YEAR
##
## Ends in an error in state: 220.
##
## assertion -> VARIES separated_nonempty_list(DOT,ident) WITH_V . naked_expression option(variation_type) [ SCOPE RULE LABEL EXCEPTION END_CODE DEFINITION DECLARATION ASSERTION ]
##
## The known suffix of the stack is as follows:
## VARIES separated_nonempty_list(DOT,ident) WITH_V
##

the variable varies with an expression that was expected here

source_file: BEGIN_CODE SCOPE UIDENT COLON ASSERTION VARIES YEAR
##
## Ends in an error in state: 218.
##
## assertion -> VARIES . separated_nonempty_list(DOT,ident) WITH_V naked_expression option(variation_type) [ SCOPE RULE LABEL EXCEPTION END_CODE DEFINITION DECLARATION ASSERTION ]
##
## The known suffix of the stack is as follows:
## VARIES
##

expecting the name of the varying variable

source_file: BEGIN_CODE SCOPE UIDENT COLON ASSERTION YEAR
##
## Ends in an error in state: 217.
##
## scope_item -> ASSERTION . assertion [ SCOPE RULE LABEL EXCEPTION END_CODE DEFINITION DECLARATION ASSERTION ]
##
## The known suffix of the stack is as follows:
## ASSERTION
##

expected an expression that shoud be asserted during execution

source_file: BEGIN_CODE SCOPE UIDENT COLON DEFINITION LIDENT DEFINED_AS YEAR
##
## Ends in an error in state: 269.
##
## definition -> option(label) option(exception_to) DEFINITION separated_nonempty_list(DOT,ident) option(definition_parameters) option(state) option(condition_consequence) DEFINED_AS . naked_expression [ SCOPE RULE LABEL EXCEPTION END_CODE DEFINITION DECLARATION ASSERTION ]
##
## The known suffix of the stack is as follows:
## option(label) option(exception_to) DEFINITION separated_nonempty_list(DOT,ident) option(definition_parameters) option(state) option(condition_consequence) DEFINED_AS
##

expected an expression for the definition

source_file: BEGIN_CODE SCOPE UIDENT COLON DEFINITION LIDENT OF LIDENT DECREASING
##
## Ends in an error in state: 266.
##
## definition -> option(label) option(exception_to) DEFINITION separated_nonempty_list(DOT,ident) option(definition_parameters) . option(state) option(condition_consequence) DEFINED_AS naked_expression [ SCOPE RULE LABEL EXCEPTION END_CODE DEFINITION DECLARATION ASSERTION ]
##
## The known suffix of the stack is as follows:
## option(label) option(exception_to) DEFINITION separated_nonempty_list(DOT,ident) option(definition_parameters)
##

expected a expression for defining this function, introduced by the defined as keyword


source_file: BEGIN_CODE SCOPE UIDENT COLON DEFINITION LIDENT WITH_V
##
## Ends in an error in state: 265.
##
## definition -> option(label) option(exception_to) DEFINITION separated_nonempty_list(DOT,ident) . option(definition_parameters) option(state) option(condition_consequence) DEFINED_AS naked_expression [ SCOPE RULE LABEL EXCEPTION END_CODE DEFINITION DECLARATION ASSERTION ]
##
## The known suffix of the stack is as follows:
## option(label) option(exception_to) DEFINITION separated_nonempty_list(DOT,ident)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production separated_nonempty_list(DOT,ident) -> ident
##

expected the defined as keyword to introduce the definition of this variable

source_file: BEGIN_CODE SCOPE UIDENT COLON DEFINITION YEAR
##
## Ends in an error in state: 264.
##
## definition -> option(label) option(exception_to) DEFINITION . separated_nonempty_list(DOT,ident) option(definition_parameters) option(state) option(condition_consequence) DEFINED_AS naked_expression [ SCOPE RULE LABEL EXCEPTION END_CODE DEFINITION DECLARATION ASSERTION ]
##
## The known suffix of the stack is as follows:
## option(label) option(exception_to) DEFINITION
##

expected the name of the variable you want to define

source_file: BEGIN_CODE SCOPE UIDENT COLON EXCEPTION LIDENT YEAR
##
## Ends in an error in state: 247.
##
## definition -> option(label) option(exception_to) . DEFINITION separated_nonempty_list(DOT,ident) option(definition_parameters) option(state) option(condition_consequence) DEFINED_AS naked_expression [ SCOPE RULE LABEL EXCEPTION END_CODE DEFINITION DECLARATION ASSERTION ]
## rule -> option(label) option(exception_to) . RULE rule_expr option(condition_consequence) option(state) rule_consequence [ SCOPE RULE LABEL EXCEPTION END_CODE DEFINITION DECLARATION ASSERTION ]
##
## The known suffix of the stack is as follows:
## option(label) option(exception_to)
##

expected a rule or a definition after the exception declaration

source_file: BEGIN_CODE SCOPE UIDENT COLON EXCEPTION YEAR
##
## Ends in an error in state: 244.
##
## exception_to -> EXCEPTION . option(ident) [ RULE DEFINITION ]
##
## The known suffix of the stack is as follows:
## EXCEPTION
##

expected the label to which the exception is referring back

source_file: BEGIN_CODE SCOPE UIDENT COLON LABEL LIDENT DEFINED_AS
##
## Ends in an error in state: 243.
##
## definition -> option(label) . option(exception_to) DEFINITION separated_nonempty_list(DOT,ident) option(definition_parameters) option(state) option(condition_consequence) DEFINED_AS naked_expression [ SCOPE RULE LABEL EXCEPTION END_CODE DEFINITION DECLARATION ASSERTION ]
## rule -> option(label) . option(exception_to) RULE rule_expr option(condition_consequence) option(state) rule_consequence [ SCOPE RULE LABEL EXCEPTION END_CODE DEFINITION DECLARATION ASSERTION ]
##
## The known suffix of the stack is as follows:
## option(label)
##

expected a rule or a definition after the label declaration

source_file: BEGIN_CODE SCOPE UIDENT COLON LABEL YEAR
##
## Ends in an error in state: 215.
##
## label -> LABEL . ident [ RULE EXCEPTION DEFINITION ]
##
## The known suffix of the stack is as follows:
## LABEL
##

expected the name of the label

source_file: BEGIN_CODE SCOPE UIDENT COLON RULE LIDENT DOT YEAR
##
## Ends in an error in state: 227.
##
## separated_nonempty_list(DOT,ident) -> ident DOT . separated_nonempty_list(DOT,ident) [ WITH_V UNDER_CONDITION STATE OF NOT FILLED DEFINED_AS BY ]
##
## The known suffix of the stack is as follows:
## ident DOT
##

expected a struct field or a sub-scope context item after the dot

source_file: BEGIN_CODE SCOPE UIDENT COLON RULE LIDENT NOT FALSE
##
## Ends in an error in state: 262.
##
## rule_consequence -> option(NOT) . FILLED [ SCOPE RULE LABEL EXCEPTION END_CODE DEFINITION DECLARATION ASSERTION ]
##
## The known suffix of the stack is as follows:
## option(NOT)
##

expected the filled keyword the this rule

source_file: BEGIN_CODE SCOPE UIDENT COLON RULE LIDENT OF LIDENT YEAR
##
## Ends in an error in state: 254.
##
## rule -> option(label) option(exception_to) RULE rule_expr . option(condition_consequence) option(state) rule_consequence [ SCOPE RULE LABEL EXCEPTION END_CODE DEFINITION DECLARATION ASSERTION ]
##
## The known suffix of the stack is as follows:
## option(label) option(exception_to) RULE rule_expr
##

expected the expression of the rule

source_file: BEGIN_CODE SCOPE UIDENT COLON RULE LIDENT OF YEAR
##
## Ends in an error in state: 250.
##
## definition_parameters -> OF . ident [ UNDER_CONDITION STATE NOT FILLED DEFINED_AS ]
##
## The known suffix of the stack is as follows:
## OF
##

expected the name of the parameter for this dependent variable


source_file: BEGIN_CODE SCOPE UIDENT COLON RULE LIDENT WITH_V
##
## Ends in an error in state: 249.
##
## rule_expr -> separated_nonempty_list(DOT,ident) . option(definition_parameters) [ UNDER_CONDITION STATE NOT FILLED ]
##
## The known suffix of the stack is as follows:
## separated_nonempty_list(DOT,ident)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 226, spurious reduction of production separated_nonempty_list(DOT,ident) -> ident
##

expected a condition or a consequence for this rule

source_file: BEGIN_CODE SCOPE UIDENT COLON RULE LIDENT YEAR
##
## Ends in an error in state: 226.
##
## separated_nonempty_list(DOT,ident) -> ident . [ WITH_V UNDER_CONDITION STATE OF NOT FILLED DEFINED_AS BY ]
## separated_nonempty_list(DOT,ident) -> ident . DOT separated_nonempty_list(DOT,ident) [ WITH_V UNDER_CONDITION STATE OF NOT FILLED DEFINED_AS BY ]
##
## The known suffix of the stack is as follows:
## ident
##

expected a condition or a consequence for this rule, or the rest of the variable qualified name

source_file: BEGIN_CODE SCOPE UIDENT COLON RULE YEAR
##
## Ends in an error in state: 248.
##
## rule -> option(label) option(exception_to) RULE . rule_expr option(condition_consequence) option(state) rule_consequence [ SCOPE RULE LABEL EXCEPTION END_CODE DEFINITION DECLARATION ASSERTION ]
##
## The known suffix of the stack is as follows:
## option(label) option(exception_to) RULE
##

expected the name of the variable subject to the rule

source_file: BEGIN_CODE SCOPE UIDENT COLON YEAR
##
## Ends in an error in state: 214.
##
## code_item -> SCOPE constructor option(scope_use_condition) COLON . nonempty_list(scope_item) [ SCOPE END_CODE DECLARATION ]
##
## The known suffix of the stack is as follows:
## SCOPE constructor option(scope_use_condition) COLON
##

expected a scope use item: a rule, definition or assertion





source_file: BEGIN_CODE SCOPE UIDENT UNDER_CONDITION UIDENT YEAR
##
## Ends in an error in state: 118.
##
## naked_expression -> constructor . enum_content_opt [ XOR WITH WE_HAVE THEN SUCH SEMICOLON SCOPE RULE RBRACKET RPAREN RBRACE PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER LABEL IS INCREASING IN GREATER_EQUAL GREATER FOR EXCEPTION EQUAL END_CODE ELSE DOT DIV DEFINITION DECREASING DECLARATION CONTAINS CONSEQUENCE COLON ASSERTION AND ALT ]
## naked_expression -> constructor . DOT constructor enum_content_opt [ XOR WITH WE_HAVE THEN SUCH SEMICOLON SCOPE RULE RBRACKET RPAREN RBRACE PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER LABEL IS INCREASING IN GREATER_EQUAL GREATER FOR EXCEPTION EQUAL END_CODE ELSE DOT DIV DEFINITION DECREASING DECLARATION CONTAINS CONSEQUENCE COLON ASSERTION AND ALT ]
## naked_expression -> constructor . LBRACE nonempty_list(preceded(ALT,struct_content_field)) RBRACE [ XOR WITH WE_HAVE THEN SUCH SEMICOLON SCOPE RULE RBRACKET RPAREN RBRACE PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER LABEL IS INCREASING IN GREATER_EQUAL GREATER FOR EXCEPTION EQUAL END_CODE ELSE DOT DIV DEFINITION DECREASING DECLARATION CONTAINS CONSEQUENCE COLON ASSERTION AND ALT ]
## naked_expression -> constructor . DOT constructor LBRACE nonempty_list(preceded(ALT,struct_content_field)) RBRACE [ XOR WITH WE_HAVE THEN SUCH SEMICOLON SCOPE RULE RBRACKET RPAREN RBRACE PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER LABEL IS INCREASING IN GREATER_EQUAL GREATER FOR EXCEPTION EQUAL END_CODE ELSE DOT DIV DEFINITION DECREASING DECLARATION CONTAINS CONSEQUENCE COLON ASSERTION AND ALT ]
##
## The known suffix of the stack is as follows:
## constructor
##

expected a payload for the enum case constructor, or the rest of the expression (with an operator ?)

source_file: BEGIN_CODE SCOPE UIDENT UNDER_CONDITION EXISTS LIDENT YEAR
##
## Ends in an error in state: 65.
##
## naked_expression -> EXISTS ident . AMONG naked_expression SUCH THAT naked_expression [ XOR WITH WE_HAVE THEN SUCH SEMICOLON SCOPE RULE RBRACKET RPAREN RBRACE PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER LABEL IS INCREASING IN GREATER_EQUAL GREATER FOR EXCEPTION EQUAL END_CODE ELSE DOT DIV DEFINITION DECREASING DECLARATION CONTAINS CONSEQUENCE COLON ASSERTION AND ALT ]
##
## The known suffix of the stack is as follows:
## EXISTS ident
##

expected the "in" keyword to continue this existential test

source_file: BEGIN_CODE SCOPE UIDENT UNDER_CONDITION EXISTS YEAR
##
## Ends in an error in state: 64.
##
## naked_expression -> EXISTS . ident AMONG naked_expression SUCH THAT naked_expression [ XOR WITH WE_HAVE THEN SUCH SEMICOLON SCOPE RULE RBRACKET RPAREN RBRACE PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER LABEL IS INCREASING IN GREATER_EQUAL GREATER FOR EXCEPTION EQUAL END_CODE ELSE DOT DIV DEFINITION DECREASING DECLARATION CONTAINS CONSEQUENCE COLON ASSERTION AND ALT ]
##
## The known suffix of the stack is as follows:
## EXISTS
##

expected an identifier that will designate the existential witness for the test

source_file: BEGIN_CODE SCOPE UIDENT UNDER_CONDITION FOR ALL LIDENT YEAR
##
## Ends in an error in state: 61.
##
## naked_expression -> FOR ALL ident . AMONG naked_expression WE_HAVE naked_expression [ XOR WITH WE_HAVE THEN SUCH SEMICOLON SCOPE RULE RBRACKET RPAREN RBRACE PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER LABEL IS INCREASING IN GREATER_EQUAL GREATER FOR EXCEPTION EQUAL END_CODE ELSE DOT DIV DEFINITION DECREASING DECLARATION CONTAINS CONSEQUENCE COLON ASSERTION AND ALT ]
##
## The known suffix of the stack is as follows:
## FOR ALL ident
##

expected the "in" keyword for the rest of the universal test

source_file: BEGIN_CODE SCOPE UIDENT UNDER_CONDITION FOR ALL YEAR
##
## Ends in an error in state: 60.
##
## naked_expression -> FOR ALL . ident AMONG naked_expression WE_HAVE naked_expression [ XOR WITH WE_HAVE THEN SUCH SEMICOLON SCOPE RULE RBRACKET RPAREN RBRACE PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER LABEL IS INCREASING IN GREATER_EQUAL GREATER FOR EXCEPTION EQUAL END_CODE ELSE DOT DIV DEFINITION DECREASING DECLARATION CONTAINS CONSEQUENCE COLON ASSERTION AND ALT ]
##
## The known suffix of the stack is as follows:
## FOR ALL
##

expected an identifier for the bound variable of the universal test

source_file: BEGIN_CODE SCOPE UIDENT UNDER_CONDITION FOR YEAR
##
## Ends in an error in state: 59.
##
## naked_expression -> FOR . ALL ident AMONG naked_expression WE_HAVE naked_expression [ XOR WITH WE_HAVE THEN SUCH SEMICOLON SCOPE RULE RBRACKET RPAREN RBRACE PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER LABEL IS INCREASING IN GREATER_EQUAL GREATER FOR EXCEPTION EQUAL END_CODE ELSE DOT DIV DEFINITION DECREASING DECLARATION CONTAINS CONSEQUENCE COLON ASSERTION AND ALT ]
##
## The known suffix of the stack is as follows:
## FOR
##

expected the "all" keyword to mean the "for all" construction of the universal test

source_file: BEGIN_CODE SCOPE UIDENT UNDER_CONDITION IF TRUE SEMICOLON
##
## Ends in an error in state: 162.
##
## naked_expression -> naked_expression . DOT ident [ XOR WITH THEN PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . DOT constructor DOT ident [ XOR WITH THEN PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . OF naked_expression [ XOR WITH THEN PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . WITH constructor_binding [ XOR WITH THEN PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . CONTAINS naked_expression [ XOR WITH THEN PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . FOR ident AMONG naked_expression [ XOR WITH THEN PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . MULT naked_expression [ XOR WITH THEN PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . DIV naked_expression [ XOR WITH THEN PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . PLUS naked_expression [ XOR WITH THEN PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . MINUS naked_expression [ XOR WITH THEN PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . PLUSPLUS naked_expression [ XOR WITH THEN PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . compare_op naked_expression [ XOR WITH THEN PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . OR naked_expression [ XOR WITH THEN PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . XOR naked_expression [ XOR WITH THEN PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . AND naked_expression [ XOR WITH THEN PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> IF naked_expression . THEN naked_expression ELSE naked_expression [ XOR WITH WE_HAVE THEN SUCH SEMICOLON SCOPE RULE RBRACKET RPAREN RBRACE PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER LABEL IS INCREASING IN GREATER_EQUAL GREATER FOR EXCEPTION EQUAL END_CODE ELSE DOT DIV DEFINITION DECREASING DECLARATION CONTAINS CONSEQUENCE COLON ASSERTION AND ALT ]
##
## The known suffix of the stack is as follows:
## IF naked_expression
##

expected the "then" keyword as the conditional expression is complete




source_file: BEGIN_CODE SCOPE UIDENT UNDER_CONDITION IF YEAR
##
## Ends in an error in state: 57.
##
## naked_expression -> IF . naked_expression THEN naked_expression ELSE naked_expression [ XOR WITH WE_HAVE THEN SUCH SEMICOLON SCOPE RULE RBRACKET RPAREN RBRACE PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER LABEL IS INCREASING IN GREATER_EQUAL GREATER FOR EXCEPTION EQUAL END_CODE ELSE DOT DIV DEFINITION DECREASING DECLARATION CONTAINS CONSEQUENCE COLON ASSERTION AND ALT ]
##
## The known suffix of the stack is as follows:
## IF
##

expected an expression for the test of the conditional

source_file: BEGIN_CODE SCOPE UIDENT UNDER_CONDITION INT_LITERAL WITH_V
##
## Ends in an error in state: 51.
##
## literal -> INT_LITERAL . option(addpos(unit_literal)) [ XOR WITH WE_HAVE THEN SUCH SEMICOLON SCOPE RULE RBRACKET RPAREN RBRACE PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER LABEL IS INCREASING IN GREATER_EQUAL GREATER FOR EXCEPTION EQUAL END_CODE ELSE DOT DIV DEFINITION DECREASING DECLARATION CONTAINS CONSEQUENCE COLON ASSERTION AND ALT ]
##
## The known suffix of the stack is as follows:
## INT_LITERAL
##

expected a unit for this literal, or a valid operator to complete the expression

source_file: BEGIN_CODE SCOPE UIDENT UNDER_CONDITION LPAREN TRUE THEN
##
## Ends in an error in state: 170.
##
## naked_expression -> LPAREN naked_expression . RPAREN [ XOR WITH WE_HAVE THEN SUCH SEMICOLON SCOPE RULE RBRACKET RPAREN RBRACE PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER LABEL IS INCREASING IN GREATER_EQUAL GREATER FOR EXCEPTION EQUAL END_CODE ELSE DOT DIV DEFINITION DECREASING DECLARATION CONTAINS CONSEQUENCE COLON ASSERTION AND ALT ]
## naked_expression -> naked_expression . DOT ident [ XOR WITH RPAREN PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . DOT constructor DOT ident [ XOR WITH RPAREN PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . OF naked_expression [ XOR WITH RPAREN PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . WITH constructor_binding [ XOR WITH RPAREN PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . CONTAINS naked_expression [ XOR WITH RPAREN PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . FOR ident AMONG naked_expression [ XOR WITH RPAREN PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . MULT naked_expression [ XOR WITH RPAREN PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . DIV naked_expression [ XOR WITH RPAREN PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . PLUS naked_expression [ XOR WITH RPAREN PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . MINUS naked_expression [ XOR WITH RPAREN PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . PLUSPLUS naked_expression [ XOR WITH RPAREN PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . compare_op naked_expression [ XOR WITH RPAREN PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . OR naked_expression [ XOR WITH RPAREN PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . XOR naked_expression [ XOR WITH RPAREN PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . AND naked_expression [ XOR WITH RPAREN PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
##
## The known suffix of the stack is as follows:
## LPAREN naked_expression
##

unmatched parenthesis that should have been closed by here

source_file: BEGIN_CODE SCOPE UIDENT UNDER_CONDITION LPAREN YEAR
##
## Ends in an error in state: 47.
##
## naked_expression -> LPAREN . naked_expression RPAREN [ XOR WITH WE_HAVE THEN SUCH SEMICOLON SCOPE RULE RBRACKET RPAREN RBRACE PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER LABEL IS INCREASING IN GREATER_EQUAL GREATER FOR EXCEPTION EQUAL END_CODE ELSE DOT DIV DEFINITION DECREASING DECLARATION CONTAINS CONSEQUENCE COLON ASSERTION AND ALT ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

expected an expression inside the parenthesis


source_file: BEGIN_CODE SCOPE UIDENT UNDER_CONDITION LBRACKET TRUE THEN
##
## Ends in an error in state: 173.
##
## naked_expression -> naked_expression . DOT ident [ XOR WITH SEMICOLON RBRACKET PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . DOT constructor DOT ident [ XOR WITH SEMICOLON RBRACKET PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . OF naked_expression [ XOR WITH SEMICOLON RBRACKET PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . WITH constructor_binding [ XOR WITH SEMICOLON RBRACKET PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . CONTAINS naked_expression [ XOR WITH SEMICOLON RBRACKET PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . FOR ident AMONG naked_expression [ XOR WITH SEMICOLON RBRACKET PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . MULT naked_expression [ XOR WITH SEMICOLON RBRACKET PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . DIV naked_expression [ XOR WITH SEMICOLON RBRACKET PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . PLUS naked_expression [ XOR WITH SEMICOLON RBRACKET PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . MINUS naked_expression [ XOR WITH SEMICOLON RBRACKET PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . PLUSPLUS naked_expression [ XOR WITH SEMICOLON RBRACKET PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . compare_op naked_expression [ XOR WITH SEMICOLON RBRACKET PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . OR naked_expression [ XOR WITH SEMICOLON RBRACKET PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . XOR naked_expression [ XOR WITH SEMICOLON RBRACKET PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> naked_expression . AND naked_expression [ XOR WITH SEMICOLON RBRACKET PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## separated_nonempty_list(SEMICOLON,expression) -> naked_expression . [ RBRACKET ]
## separated_nonempty_list(SEMICOLON,expression) -> naked_expression . SEMICOLON separated_nonempty_list(SEMICOLON,expression) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## naked_expression
##

expected a semicolon or a right square bracket after the collection element

source_file: BEGIN_CODE SCOPE UIDENT UNDER_CONDITION LBRACKET YEAR
##
## Ends in an error in state: 46.
##
## naked_expression -> LBRACKET . loption(separated_nonempty_list(SEMICOLON,expression)) RBRACKET [ XOR WITH WE_HAVE THEN SUCH SEMICOLON SCOPE RULE RBRACKET RPAREN RBRACE PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER LABEL IS INCREASING IN GREATER_EQUAL GREATER FOR EXCEPTION EQUAL END_CODE ELSE DOT DIV DEFINITION DECREASING DECLARATION CONTAINS CONSEQUENCE COLON ASSERTION AND ALT ]
##
## The known suffix of the stack is as follows:
## LBRACKET
##

expected a collection element



source_file: BEGIN_CODE SCOPE UIDENT UNDER_CONDITION MATCH TRUE WITH ALT YEAR
##
## Ends in an error in state: 180.
##
## nonempty_list(addpos(preceded(ALT,match_arm))) -> ALT . match_arm [ XOR WITH WE_HAVE THEN SUCH SEMICOLON SCOPE RULE RBRACKET RPAREN RBRACE PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER LABEL IS INCREASING IN GREATER_EQUAL GREATER FOR EXCEPTION EQUAL END_CODE ELSE DOT DIV DEFINITION DECREASING DECLARATION CONTAINS CONSEQUENCE COLON ASSERTION AND ALT ]
## nonempty_list(addpos(preceded(ALT,match_arm))) -> ALT . match_arm nonempty_list(addpos(preceded(ALT,match_arm))) [ XOR WITH WE_HAVE THEN SUCH SEMICOLON SCOPE RULE RBRACKET RPAREN RBRACE PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER LABEL IS INCREASING IN GREATER_EQUAL GREATER FOR EXCEPTION EQUAL END_CODE ELSE DOT DIV DEFINITION DECREASING DECLARATION CONTAINS CONSEQUENCE COLON ASSERTION AND ALT ]
##
## The known suffix of the stack is as follows:
## ALT
##

expected the name of the constructor for the enum case in the pattern matching

source_file: BEGIN_CODE SCOPE UIDENT UNDER_CONDITION MATCH TRUE WITH YEAR
##
## Ends in an error in state: 179.
##
## naked_expression -> naked_expression WITH . constructor_binding [ XOR WITH PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS AND ]
## naked_expression -> MATCH naked_expression WITH . nonempty_list(addpos(preceded(ALT,match_arm))) [ XOR WITH WE_HAVE THEN SUCH SEMICOLON SCOPE RULE RBRACKET RPAREN RBRACE PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER LABEL IS INCREASING IN GREATER_EQUAL GREATER FOR EXCEPTION EQUAL END_CODE ELSE DOT DIV DEFINITION DECREASING DECLARATION CONTAINS CONSEQUENCE COLON ASSERTION AND ALT ]
##
## The known suffix of the stack is as follows:
## MATCH naked_expression WITH
##

expected a pattern matching case

source_file: BEGIN_CODE SCOPE UIDENT UNDER_CONDITION MATCH YEAR
##
## Ends in an error in state: 45.
##
## naked_expression -> MATCH . naked_expression WITH nonempty_list(addpos(preceded(ALT,match_arm))) [ XOR WITH WE_HAVE THEN SUCH SEMICOLON SCOPE RULE RBRACKET RPAREN RBRACE PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER LABEL IS INCREASING IN GREATER_EQUAL GREATER FOR EXCEPTION EQUAL END_CODE ELSE DOT DIV DEFINITION DECREASING DECLARATION CONTAINS CONSEQUENCE COLON ASSERTION AND ALT ]
##
## The known suffix of the stack is as follows:
## MATCH
##

expected an expression to match with

source_file: BEGIN_CODE SCOPE UIDENT UNDER_CONDITION TRUE DOT UIDENT DOT YEAR
##
## Ends in an error in state: 94.
##
## naked_expression -> naked_expression DOT constructor DOT . ident [ XOR WITH WE_HAVE THEN SUCH SEMICOLON SCOPE RULE RBRACKET RPAREN RBRACE PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER LABEL IS INCREASING IN GREATER_EQUAL GREATER FOR EXCEPTION EQUAL END_CODE ELSE DOT DIV DEFINITION DECREASING DECLARATION CONTAINS CONSEQUENCE COLON ASSERTION AND ALT ]
##
## The known suffix of the stack is as follows:
## naked_expression DOT constructor DOT
##

expected the rest of the path after the dot

source_file: BEGIN_CODE SCOPE UIDENT UNDER_CONDITION TRUE YEAR
##
## Ends in an error in state: 211.
##
## naked_expression -> naked_expression . DOT ident [ XOR WITH PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS COLON AND ]
## naked_expression -> naked_expression . DOT constructor DOT ident [ XOR WITH PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS COLON AND ]
## naked_expression -> naked_expression . OF naked_expression [ XOR WITH PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS COLON AND ]
## naked_expression -> naked_expression . WITH constructor_binding [ XOR WITH PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS COLON AND ]
## naked_expression -> naked_expression . CONTAINS naked_expression [ XOR WITH PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS COLON AND ]
## naked_expression -> naked_expression . FOR ident AMONG naked_expression [ XOR WITH PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS COLON AND ]
## naked_expression -> naked_expression . MULT naked_expression [ XOR WITH PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS COLON AND ]
## naked_expression -> naked_expression . DIV naked_expression [ XOR WITH PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS COLON AND ]
## naked_expression -> naked_expression . PLUS naked_expression [ XOR WITH PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS COLON AND ]
## naked_expression -> naked_expression . MINUS naked_expression [ XOR WITH PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS COLON AND ]
## naked_expression -> naked_expression . PLUSPLUS naked_expression [ XOR WITH PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS COLON AND ]
## naked_expression -> naked_expression . compare_op naked_expression [ XOR WITH PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS COLON AND ]
## naked_expression -> naked_expression . OR naked_expression [ XOR WITH PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS COLON AND ]
## naked_expression -> naked_expression . XOR naked_expression [ XOR WITH PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS COLON AND ]
## naked_expression -> naked_expression . AND naked_expression [ XOR WITH PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER GREATER_EQUAL GREATER FOR EQUAL DOT DIV CONTAINS COLON AND ]
## scope_use_condition -> UNDER_CONDITION naked_expression . [ COLON ]
##
## The known suffix of the stack is as follows:
## UNDER_CONDITION naked_expression
##

expected the function application operator

source_file: BEGIN_CODE SCOPE UIDENT UNDER_CONDITION BAR YEAR
##
## Ends in an error in state: 11.
##
## literal -> BAR . DATE_LITERAL BAR [ XOR WITH WE_HAVE THEN SUCH SEMICOLON SCOPE RULE RBRACKET RPAREN RBRACE PLUSPLUS PLUS OR OF NOT_EQUAL MULT MINUS LESSER_EQUAL LESSER LABEL IS INCREASING IN GREATER_EQUAL GREATER FOR EXCEPTION EQUAL END_CODE ELSE DOT DIV DEFINITION DECREASING DECLARATION CONTAINS CONSEQUENCE COLON ASSERTION AND ALT ]
##
## The known suffix of the stack is as follows:
## BAR
##

expected the year for this date literal

source_file: BEGIN_CODE SCOPE UIDENT UNDER_CONDITION YEAR
##
## Ends in an error in state: 10.
##
## scope_use_condition -> UNDER_CONDITION . naked_expression [ COLON ]
##
## The known suffix of the stack is as follows:
## UNDER_CONDITION
##

expected an expression

source_file: BEGIN_CODE SCOPE UIDENT YEAR
##
## Ends in an error in state: 9.
##
## code_item -> SCOPE constructor . option(scope_use_condition) COLON nonempty_list(scope_item) [ SCOPE END_CODE DECLARATION ]
##
## The known suffix of the stack is as follows:
## SCOPE constructor
##

expected a scope use condition or the content of this scope use

source_file: BEGIN_CODE SCOPE YEAR
##
## Ends in an error in state: 7.
##
## code_item -> SCOPE . constructor option(scope_use_condition) COLON nonempty_list(scope_item) [ SCOPE END_CODE DECLARATION ]
##
## The known suffix of the stack is as follows:
## SCOPE
##

expected the name of the scope being used

source_file: BEGIN_CODE YEAR
##
## Ends in an error in state: 351.
##
## source_file_item -> BEGIN_CODE . code END_CODE [ LAW_TEXT LAW_HEADING EOF BEGIN_METADATA BEGIN_DIRECTIVE BEGIN_CODE ]
##
## The known suffix of the stack is as follows:
## BEGIN_CODE
##

expected some declaration or scope use inside this code block






source_file: LAW_TEXT YEAR
##
## Ends in an error in state: 1.
##
## nonempty_list(LAW_TEXT) -> LAW_TEXT . [ SCOPE LAW_TEXT LAW_HEADING EOF END_CODE DECLARATION BEGIN_METADATA BEGIN_DIRECTIVE BEGIN_CODE ]
## nonempty_list(LAW_TEXT) -> LAW_TEXT . nonempty_list(LAW_TEXT) [ SCOPE LAW_TEXT LAW_HEADING EOF END_CODE DECLARATION BEGIN_METADATA BEGIN_DIRECTIVE BEGIN_CODE ]
##
## The known suffix of the stack is as follows:
## LAW_TEXT
##

expected some law text or code block

source_file: YEAR
##
## Ends in an error in state: 0.
##
## source_file' -> . source_file [ # ]
##
## The known suffix of the stack is as follows:
##
##

expected some law text or code block
